package itn_orchestrator

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"

	logging "github.com/ipfs/go-log/v2"
)

// RoundInfo holds information about a single round
type RoundInfo struct {
	PaymentCount    int     `json:"payment_count"`
	ZkappCount      int     `json:"zkapp_count"`
	PaymentTps      float64 `json:"payment_tps"`
	ZkappTps        float64 `json:"zkapp_tps"`
	DurationMinutes int     `json:"duration_minutes"`
	MaxCost         bool    `json:"max_cost"`
}

// ExperimentInfo holds information about the entire experiment
type ExperimentInfo []RoundInfo

func fund(p FundParams) GeneratedCommand {
	return GeneratedCommand{Action: FundAction{}.Name(), Params: p}
}

// EncodeToWriter encodes experiment parameters to a writer using JSON encoding
// Returns experiment info and error
// isService: if true, uses secure logging that doesn't expose passwords
func EncodeToWriter(p *GenParams, writer io.Writer, isService bool) (ExperimentInfo, error) {
	encoder := json.NewEncoder(writer)
	var errors []string

	writeComment := func(comment string) {
		if err := encoder.Encode(comment); err != nil {
			errors = append(errors, fmt.Sprintf("Error writing comment: %v", err))
		}
	}
	writeCommand := func(cmd GeneratedCommand) {
		if comment := cmd.Comment(); comment != "" {
			writeComment(comment)
		}
		if err := encoder.Encode(cmd); err != nil {
			errors = append(errors, fmt.Sprintf("Error writing command: %v", err))
		}
	}

	experimentInfo := EncodeWithContext(p, writeCommand, writeComment, isService)

	if len(errors) > 0 {
		return ExperimentInfo{}, fmt.Errorf("encoding errors: %s", strings.Join(errors, "; "))
	}
	return experimentInfo, nil
}

// RunExperiment executes an experiment from a JSON decoder with the given configuration
// Returns error if execution fails, nil on success
func RunExperiment(inDecoder *json.Decoder, config Config, log logging.StandardLogger) error {
	outCache := EmptyOutputCache()
	rconfig := ResolutionConfig{
		OutputCache: outCache,
	}
	step := 0
	var prevAction BatchAction
	var actionAccum []ActionIO

	handlePrevAction := func() error {
		log.Infof("Performing steps %s (%d-%d)", prevAction.Name(), step-len(actionAccum), step-1)
		err := prevAction.RunMany(config, actionAccum)
		if err != nil {
			return &OrchestratorError{
				Message: fmt.Sprintf("Error running steps %d-%d: %v", step-len(actionAccum), step-1, err),
				Code:    9,
			}
		}
		prevAction = nil
		actionAccum = nil
		return nil
	}

	err := RunActions(inDecoder, config, outCache, log, step,
		handlePrevAction, &actionAccum, rconfig, &prevAction)
	if err != nil {
		if orchErr, ok := err.(*OrchestratorError); ok {
			log.Errorf("Experiment finished with error: %v", orchErr)
			return orchErr
		}
		return err
	}

	if prevAction != nil {
		if err := handlePrevAction(); err != nil {
			log.Errorf("Error running action: %s due to: %v", prevAction.Name(), err)
			// Check if context is canceled
			if config.Ctx.Err() != nil {
				return config.Ctx.Err()
			}
			return &OrchestratorError{
				Message: fmt.Sprintf("Error running previous action: %v", err),
				Code:    9,
			}
		}
	}
	return nil
}

func Encode(p *GenParams, writeCommand func(GeneratedCommand), writeComment func(string)) ExperimentInfo {
	return EncodeWithContext(p, writeCommand, writeComment, false)
}

func EncodeWithContext(p *GenParams, writeCommand func(GeneratedCommand), writeComment func(string), isService bool) ExperimentInfo {
	// For orchestrator service, show experiment setup instead of command args (which contain passwords)
	// For standalone generator, show command args as before
	if isService {
		setupJSON, err := json.Marshal(p)
		if err != nil {
			writeComment("Generated by orchestrator service (error serializing setup)")
		} else {
			writeComment("Generated by orchestrator service with setup: " + string(setupJSON))
		}
	} else {
		writeComment("Generated with: " + strings.Join(os.Args, " "))
	}
	if p.ZkappSoftLimit > -2 {
		writeCommand(Discovery(DiscoveryParams{}))
		writeComment(fmt.Sprintf("Setting zkapp soft limit to %d", p.ZkappSoftLimit))
		writeCommand(ZkappSoftLimit(-1, "participant", p.ZkappSoftLimit))
	}
	cmds := []GeneratedCommand{}
	fundCmds := []FundParams{}
	var rounds []RoundInfo

	writeComment("Funding keys for the experiment")
	for r := 0; r < p.Rounds; r++ {
		round := p.Generate(r)
		cmds = append(cmds, round.Commands...)
		if round.PaymentFundCommand != nil {
			fundCmds = append(fundCmds, *round.PaymentFundCommand)
		}
		if round.ZkappFundCommand != nil {
			fundCmds = append(fundCmds, *round.ZkappFundCommand)
		}
		// Collect round info from the generated round
		rounds = append(rounds, round.RoundInfo)
	}
	privkeys := p.Privkeys
	if p.GenerateFundKeys > 0 {
		fundKeysDir := fmt.Sprintf("%s/%s", p.FundKeyPrefix, p.ExperimentName)
		privkeys = make([]string, p.GenerateFundKeys)
		privkeyAmounts := make([]uint64, p.GenerateFundKeys)
		for i := range privkeys {
			privkeys[i] = fmt.Sprintf("%s/key-0-%d", fundKeysDir, i)
		}
		for i, f := range fundCmds {
			i_ := (i * p.PrivkeysPerFundCmd) % p.GenerateFundKeys
			itemsPerFundKey := f.Num/p.PrivkeysPerFundCmd + 1
			perGeneratedKey := f.Amount / uint64(f.Num) * uint64(itemsPerFundKey)
			for j := i_; j < (i_ + p.PrivkeysPerFundCmd); j++ {
				j_ := j % p.GenerateFundKeys
				privkeyAmounts[j_] += perGeneratedKey
			}
		}
		perKeyAmount := privkeyAmounts[0]
		for _, a := range privkeyAmounts[1:] {
			if perKeyAmount < a {
				perKeyAmount = a
			}
		}
		// Generate funding keys
		writeCommand(fund(FundParams{
			PasswordEnv: p.PasswordEnv,
			Privkeys:    p.Privkeys,
			Prefix:      fundKeysDir + "/key",
			Amount:      perKeyAmount*uint64(p.GenerateFundKeys)*3/2 + 2e9,
			Fee:         p.FundFee,
			Num:         p.GenerateFundKeys,
		}))
		writeCommand(GenWait(1))
	}
	privkeysExt := append(privkeys, privkeys...)
	for i, cmd := range fundCmds {
		i_ := (i * p.PrivkeysPerFundCmd) % len(privkeys)
		cmd.Privkeys = privkeysExt[i_:(i_ + p.PrivkeysPerFundCmd)]
		writeCommand(fund(cmd))
	}
	for _, cmd := range cmds {
		writeCommand(cmd)
	}
	return rounds
}
